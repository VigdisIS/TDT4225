\RequirePackage{filecontents}
\begin{filecontents*}{\jobname.bib}
@Book{CS,
  Title                    = {Chemistry in Space. From Interstellar Matter to Organic Life},
  Author                   = {Dieter Rehder},
  Publisher                = {John Wiley and Sons},
  Year                     = {2010},
  ISBN                     = {9783527326891},
  Keywords                 = {physics}
}

@Article{EPS,
  Title                    = {Energy Production in Stars},
  Author                   = {Hans Albrecht Bethe},
  Journal                  = {Physical Review},
  Year                     = {1939},
  Number                   = {5},
  Pages                    = {434--456},
  Volume                   = {55},
  DOI                      = {http://journals.aps.org/pr/abstract/10.1103/PhysRev.55.434},
  Keywords                 = {physics}
}

@Book{FP,
  Title                    = {Fusion Physics},
  Author                   = {Mitsuru Kikuchi and Karl Lackner and Minh Quang Tran},
  Publisher                = {International Atomic Energy Agency},
  Year                     = {2012},
  Series                   = {International Atomic Energy Agency},
  ISBN                     = {9789201304100},
  Keywords                 = {physics}
}

@Book{INP,
  Title                    = {Introductory Nuclear Physics},
  Author                   = {Kenneth S. Krane},
  Publisher                = {John Wiley and Sons},
  Year                     = {1987},
  ISBN                     = {9780471805533},
  Keywords                 = {physics}
}

@Book{kleppmann_2017,
  Title                    = {Designing Data-Intensive Applications},
  Author                   = {Kleppmann, Martin},
  Year                     = {2017}
}

@Article{Rahut_2023,
  Title                    = {Building and deploying MySQL Raft at Meta},
  Author                   = {Rahut, Anirban and Sharma, Abhinav and Shen, Yichen and Haque, Ahsanul},
  Journal                  = {Engineering at Meta},
  Year                     = {2023},
  DOI                      = {https://engineering.fb.com/2023/05/16/data-infrastructure/mysql-raft-meta/},
}

@Article{Ongaro_2014,
  Title                    = {In Search of an Understandable Consensus Algorithm},
  Author                   = {Ongaro, Diego and Ousterhout, John},
  Journal                  = {Proceedings of USENIX ATC'14},
  Year                     = {2014}
}

@Book{couloris_2011,
author = {Coulouris, George and Dollimore, Jean and Kindberg, Tim and Blair, Gordon},
title = {Distributed Systems: Concepts and Design},
year = {2011}
}



\end{filecontents*}


\documentclass[11pt,a4paper]{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{comment}
\usepackage{amsmath}
\usepackage{csquotes} % <==================================
\usepackage[%
  backend=bibtex, % biber bibtex % <=======================
  style=alphabetic,
  sorting=ynt,
]{biblatex}
\usepackage{float}
% Customized header and footer
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0.1ex}
\renewcommand{\footrulewidth}{0.1ex}
\fancyfoot[C]{\thepage}

%\bibliography{biblio} % <===============not needed =======
\addbibresource{\jobname.bib}

\fancyhead{} % clear all header fields
\fancyhead[LO]{\fontsize{8}{12} \textbf{Vigdis-Irene Steinsund}}
\fancyhead[CO]{\fontsize{10}{12} \textbf{TDT4225 - Exercise 4}}
\fancyhead[RO]{\fontsize{8}{12} \textbf{10/11/2023}}


\begin{document}
\begin{enumerate}
    \item 
        \begin{enumerate}
            \item One should use multi-leader replication in cases where 
                \begin{enumerate} 
                    \item we have multiple datacenters
                    \item we have an application that needs to continue working
                        even in cases where its connection to the internet 
                        has dropped.
                    \item we have a system in which multiple users need to be 
                        able to collaborate and edit in real time.
                \end{enumerate}
                This type of replication allows for better performance, since 
                writes can be processed locally, and then replicated 
                asynchronously to other datacenters. Additionally, this makes 
                for a higher tolerance of outages since each datacenter can 
                continue operating normally even when one datacenter has failed. 
                A replication like this will also make it so that the system
                tolerates network problems better, since a temporary network
                outage would not prevent writes from being processed.
                \\ One could use leader-based replication in single datacenters or
                in general in cases where for instance it is not a problem for 
                the system that all writes must go through this one leader, and 
                that the system won't often experience network interruption
                \autocite[pp.~168-170]{kleppmann_2017}.
            \item One should use log shipping as a replication means instead of
                just replicating the SQL statements because sending SQL
                statements can be unpredictable in terms of non-deterministic
                functions, where functions calling for a time now or a randomly
                generated number will be different on the different replicas. 
                This method can also cause unpredictable scenarios in terms of
                auto-incrementing IDs, in addition to side effects
                possibly having different results on different replicas 
                \autocite[p.~159]{kleppmann_2017}.
        \end{enumerate}
    \item 
    \begin{enumerate}
        \item The best way of supporting re-partitioning is by using a hash
            function to decide the partition for a given key. This way,
            skewed data is uniformly distributed 
            \autocite[pp.~201-205]{kleppmann_2017}.
        \item Global indexes make reads more efficient than when using a local
            index, so if the system is read-heavy, global indexes would be
            better, rather than if the system is write-heavy, in which case
            local indexes would be better \autocite[p.~208]{kleppmann_2017}.
    \end{enumerate}
    \item 
    \begin{enumerate}
        \item The given scheduel will be executed the following way using 
            read commmitted:
            \begin{enumerate}
                \item r1(A): Transaction 1 reads A. No lock conflict.
                \item w2(A): Transaction 2 wants to write to A, but must wait because A was read by Transaction 1 and the write operation cannot proceed until after Transaction 1 commits.
                \item w2(B): This operation must also wait because Transaction 2 is waiting to write to A.
                \item r1(B): Transaction 1 reads B. No lock conflict.
                \item c1: Transaction 1 commits and the lock on A is released.
                \item w2(A), w2(B): Now that Transaction 1 has committed, Transaction 2 can write to A and B.
                \item c2: Transaction 2 commits.
            \end{enumerate}
            In snapshot isolation, the given schedule will be executed the
            following way:
            \begin{enumerate}
                \item r1(A): Transaction 1 reads A and gets a snapshot of A at the time the transaction began.
                \item w2(A): Transaction 2 writes to A, which does not affect Transaction 1's snapshot.
                \item w2(B): Transaction 2 writes to B, which also does not affect Transaction 1's snapshot.
                \item r1(B): Transaction 1 reads B and sees the snapshot from when the transaction began, not the updated value from Transaction 2.
                \item c1: Transaction 1 commits.
                \item c2: Transaction 2 commits.
            \end{enumerate}
        \item Using serializable with 2PL, the given shceule will be executed
            the following way:
            \begin{enumerate}
                \item r1(A): Transaction 1 reads and gets a lock on A.
                \item w2(A): Transaction 2 wants to write to A, but must wait because A is locked by Transaction 1.
                \item w2(B): Transaction 2 wants to write to B, and since there is no lock on B, this operation can proceed. Transaction 2 now holds a lock on B.
                \item r1(B): Transaction 1 wants to read B, but must wait because B is locked by Transaction 2.
                \item c1: Transaction 1 commits. The locks on A and B are released.
                \item w2(A): Now that Transaction 1 has committed, Transaction 2 can write to A.
                \item c2: Transaction 2 commits.
            \end{enumerate}
    \end{enumerate}
    \item 
    \begin{enumerate}
        \item There can be numerous reasons as to why a message in a network 
            won't get a reply once its been sent. Some of them are:
            \begin{enumerate}
                \item The packet may be lost.
                \item It may be delayed due to it waiting in queue.
                \item The remote node may have failed, either from crashing or 
                    potentially being powered down. It may also have stopped 
                    working altogether.
                \item The response to the message could have been lost or 
                    delayed.
            \end{enumerate}
            \autocite[p.~278]{kleppmann_2017}
        \item Using clocks for last write wins could be dangerous due to the
            fact that database writes could disappear due to nodes with 
            lagging clocks being unable to overwrite any value already written
            by a node with a faster clock, until the skew has been resolved.
            Last write wins can also not differentiate between writes that
            happened sequentially in quick succession. It is also possible for 
            two nodes to generate writes with the exact same timestamp, which
            needs another tiebraker value to solve the conflict, though this 
            can lead to violations of causality 
            \autocite[pp.~292-293]{kleppmann_2017}.
    \end{enumerate}
    \item 
    \begin{enumerate}
        \item The connection between ordering, linearizability, and consensus
            is that they all deal with the issue of maintaining consistency in 
            distributed systems. Linearizability is a strong form of consistency 
            that makes it easier to understand and predict how concurrent 
            operations will behave. Consensus algorithms can be used to decide 
            on a global order of operations, which is useful for implementing 
            linearizable systems \autocite[pp.~373-375]{kleppmann_2017}.
        \item There are numerous distributed systems that are usable even when
            they are not linearizable, usually due to the fact that they provide
            other forms of consistency guarantees. Examples of these are 
            leaderless and multi-leader replication systems 
            \autocite[p.~375]{kleppmann_2017}. 
    \end{enumerate}
    \item 
    \begin{enumerate}
        \item Using logical clocks, one cannot necessarily deduce that e
            "happened before" f. This is because logical clocks only provides
            a partial ordering of events: e and f could still be concurrent 
            events even though L(e) < L(f) \autocite[p.~607]{couloris_2011}. 
            \\ If one uses vector clocks instead, one can deduce that e
            "happened before" f when V(e) < V(f), since an array of logical
            clocks are maintaned and updated based on specific rules for each 
            process in the system \autocite[p.~609]{couloris_2011}.
        \item 
            \begin{enumerate}
                \item b: (4, 0, 0)
                \item c: (0, 3, 2)
                \item k: (4, 2, 0)
                \item m: (0, 3, 0)
                \item n: (5, 4, 0)
                \item u: (0, 4, 0)
            \end{enumerate}
            \autocite[p.~610]{couloris_2011}
        \item A series of possible consistent states the system can have had 
            would be:
            \begin{enumerate}
                \item S00: Initial state where both P1 and P2 are at (0,0).
                \item S10: P1 has processed its first event, moving to (1,0).
                \item S11: P2 receives the message from P1 and moves to (1,1).
                \item S20: P1 processes another local event, moving to (2,1).
                \item S21: P2 processes a local event, moving to (2,2).
                \item S31: P1 sends a message to P2, moving to (3,2).
                \item S32: P2 receives the message from P1 and moves to (3,3).
            \end{enumerate}
            \autocite[p.~622]{couloris_2011}
    \end{enumerate}
    \item  RAFT ensures that the log is equal on all nodes in case of a crash 
        and a new leader by electing a new leader when an existing one fails,
        and accepting and replicating logs across the cluster by enforcing
        other logs to agree with the leader's log 
        \autocite[p.~307]{Ongaro_2014}. 
    \item The main advantages from introducing RAFT into MySQL was making it 
        into a truly distributed system by moving the source of truth of 
        membership and leadership inside the server, since operations like 
        promotions of new leaders and membership changes were the cause of most
        of the issues they were facing. This enabled provable correctness of 
        promotions of new leaders and any membership changes within the server
        \autocite{Rahut_2023}.
  \end{enumerate}

\newpage
\printbibliography
\end{document}
